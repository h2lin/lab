动态规划篇

### 概述

关于动态规划：

- 动态规划的算法名字，和它具体的算法没有关系。这个名字是创始人用来忽悠美国军方的，让别人不知道他到底在干啥。

- 动态规划是一种思想：充分利用已有的结果，推算之后的结果。从而避免暴力搜索，大幅降低时间复杂度。类似KMP。

- 动态规划解决的问题：一般的问题场景是，总的问题可以拆分为很多个子问题，然后可以根据子问题的局部最优，最终推导出总问题的最优解。同时前一个子问题会影响当前子问题的结果。当前子问题的最优抉择，是根据前一子问题的抉择来决定的。

- 动态规划的思路：类似高中的数列。

  - 数列是要求得到递推公式，然后根据递推公式用归纳法等方式推出通项公式。
  
  - 而动态规划的状态转移公式，就相当于数组的递推公式。不同的是，动态规划无需求出通项公式（也不一定能求出来），而是直接从初值开始，根据状态转移公式，暴力推导出来。
  
  - 所以动态规划算法的关键就是，**确定dp[]数组的含义**。有了这个含义，就很容易得到状态转移公式，以及赋初值、遍历。

**动态规划五部曲**：

1. dp数组：确定dp数组及下标：**dp数组及下标含义**

2. 公式：确定递推公式：确定**递推公式**

3. 初始化：dp数组**如何初始化**。要先确定公式才初始化方式，因为某些情况下公式决定了数组如何初始化

4. 遍历：确定**遍历顺序**：从前往后、从后往前等

5. 举例：**举例推导**dp数组

复杂一点的递推公式，dp[i]可能是需要自己处理来推出来的。而且，递推公式是通过观察得到的。。例如：
```java
// N0096 不同的二叉搜索树，递推公式
for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                // 递推公式
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
```

### 背包问题：

解题步骤（二维数组方式）：

- dp数组以及下标的含义：dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
- 递推公式：每次有两种情况，背包里放第i个物品，背包里不放第i个物品。两种取最大即可：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
- **初始化方式**：注意是倒叙，否则会多次重复放入物品。直接手动初始化也行，放得下就是物品0的价值，放不下就是0，如果有物品价值为负则是无穷小。**其他解法和题型，如一维数组等，要特别注意遍历顺序。**
   ```java
      // 倒叙遍历
      for (int j = bagWeight; j >= weight[0]; j--) {
          dp[0][j] = dp[0][j - weight[0]] + value[0]; // 初始化i为0时候的情况
      }
   ```
- **遍历顺序**：这里先容量后物品，或者先物品后容量都行。不过**其他解法和题型，如一维数组等，要特别注意遍历顺序**。
- 举例验证：略

解题步骤（一维数组方式）：可以看做是二维数组的简化版，相当于每次复制了上一层的值，复用了空间，所以少了一个维度。

- dp数组以及下标的含义：dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。其实是相当于把二维数组上一层的数据copy到本层，原本的“从0-i选取物品”被化解掉了，就只剩后半句“容量为j的背包，所背的最大物品价值”。
- 递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);。思路是一样的，j之前就两种情况，要么背了物品i，要么没背物品i，两者取最大即可。递推公式原本为dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);，copy后变为dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);，再化解就得到dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
- 初始化：容量为0，物品价值全部初始化为0即可。（如果物品价值有负，则取负无穷）
- **遍历顺序**：由于化解了一个物品增长的纬度。
  - 此时背包容量一定要从大到小遍历，否则会重复放入物品。
  - 此时一定是背包在外层循环，容量在里层循环。否则相当于是每次只放入一个物品。
- 举例验证：略。

零一背包：每个元素只能选一个：

  求最接近target的，一般是二选一，递推公式类似于：
    
    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    一维数组：dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
  
  求刚好等于target的，一般是组合类问题，两个都选，递推公式类似于：
    
    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - weight[i]];
    一维数组：dp[j] += dp[j - nums[i]]
  
  使用一维数组时遍历顺序注意考虑：nums放在外循环，target在内循环，且内循环倒序。不倒序会产生重复选取。
  
  **背包问题考虑顺序**：for循环物品在外层还是重量在外层，重量是正序循环还是倒序循环。

  
  - 零一背包： 
    - for循环内外可以调换，先遍历背包或重量都行。
    - 装满背包有几种方式的情况：for循环内外的区别是组合和排列的区别。
    - 一维数组时内层循环需要从大到小遍历。
  - 多重背包：一维数组时内层循环需要从小到大遍历。
    - 纯多重背包，即价值最大：for循环内外可以调换，先遍历背包或重量都行。
    - 装满背包有几种方式的情况：for循环内外的区别是组合和排列的区别。
    - 一维数组时内层循环需要从小到大遍历。所谓的物品无限，其实就相当于是，每次遍历都有机会放。
    - 在求装满背包有几种方案的时候，认清遍历顺序是非常关键的。 如果求组合数就是外层for循环遍历物品，
      内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。
  
  关于内外循环遍历顺序，以及内层倒序正序遍历的区分：

  - 可以看出,外层循环为背包容量,内层循环为物品时,每种背包容量下,都会按照物品大小顺序对其进行全部遍历
  也就是说,假设背包容量为3时,可放入1和2;\[1,2\]即为先在背包容量为1时放入1,再在容量为2时放入2;
  \[2,1\]即为现在背包容量为2时放入2,再在容量为1时放入1;所以这是两种不同的放入排列方式。

  - 而如果是外层循环为物品，内层循环为背包容量时,只能根据当前容量,按照物品顺序来放入,即只会出现\[1,2\]。
  
  - 简单的总结就是，物品编号在内层循环时，它有很多次机会进行全部遍历。而物品编号在外层循环时，
    总体来看，它只全部遍历了一次。所以前者是不同顺序都可以算作一次，而后者则只会记录一个顺序，
    因为总体只遍历了一次。
  - 正序倒序遍历倒比较好理解，正序时，因为引用了前面就形成的dp数据，所以物品是重复放入的。

-----------------------------------
### 打家劫舍

**打家劫舍问题，本质上就是，连续元素二选一问题**。即：
- 数组上连续元素二选一
- 成环之后连续元素二选一
- 在树上连续元素二选一

一定注意，计算某个节点的时候，是考虑抢不抢它，所以要计算抢他步枪他两种情况下的最大值，而不是一定要抢他即计算抢他的值。参见题目0337。

-----------------------------------
### 股票
**股票问题，本质上就是，取最佳间距问题**。

题型：
- 只能买卖一次：也可贪心法找最大最小。
- 可以买卖多次
- 最多可以买卖2次：多了两种状态。
- 最多可以买卖k次：多了2k种状态。
- 可以买卖多次，但是有冻结期：多了卖的是前一天冻结的股票一种状态。
- 可以买卖多次，但是有手续费：买或卖时加上收手续费的操作就行，等效的。

### 子序列问题

一般有最大长度、连续、相等等字眼。两种dp[i]定义思路
 - 以[i]结尾的最大长度：一般用于解决子数组问题。
 - 从[0-i]下标中寻找的最大长度：一般用于解决子序列问题。
 - 解决最大子序列问题时，可以手动在txt[]最开始加一个不相等的数，用来简化初始化。

### 个人思路总结，非常重要
- 动态规划的核心思路是状态转移
- 最重要的事情就是确定某一个时刻，可能的所有状态
- 且所有的状态，一定能从上一步的状态推导出来。不要再往前考虑。
- 状态转移公式从不同的角度有很多种写法，都是对的。关键是找全状态，以及写对转移逻辑。例如：N309，代码随想录的解法就不太好理解。

其他人解题思路参考：
// 思路：
//     考虑有多少种状态，每种状态有哪些选择，或者是做了哪些选择后得到哪种状态。
//     注意：到底是先选择了才有状态，还是先由状态才能选择。这里是先选择了，才有状态