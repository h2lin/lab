动态规划篇

### 概述

关于动态规划：

- 动态规划的算法名字，和它具体的算法没有关系。这个名字是创始人用来忽悠美国军方的，让别人不知道他到底在干啥。

- 动态规划是一种思想：充分利用已有的结果，推算之后的结果。从而避免暴力搜索，大幅降低时间复杂度。类似KMP。

- 动态规划解决的问题：一般的问题场景是，总的问题可以拆分为很多个子问题，然后可以根据子问题的局部最优，最终推导出总问题的最优解。同时前一个子问题会影响当前子问题的结果。当前子问题的最优抉择，是根据前一子问题的抉择来决定的。

- 动态规划的思路：类似高中的数列。

  - 数列是要求得到递推公式，然后根据递推公式用归纳法等方式推出通项公式。
  
  - 而动态规划的状态转移公式，就相当于数组的递推公式。不同的是，动态规划无需求出通项公式（也不一定能求出来），而是直接从初值开始，根据状态转移公式，暴力推导出来。
  
  - 所以动态规划算法的关键就是，**确定dp[]数组的含义**。有了这个含义，就很容易得到状态转移公式，以及赋初值、遍历。

**动态规划五部曲**：

1. dp数组：确定dp数组及下标：dp数组及下标含义

2. 公式：确定递推公式：确定递推公式

3. 初始化：dp数组如何初始化。要先确定公式才初始化方式，因为某些情况下公式决定了数组如何初始化

4. 遍历：确定遍历顺序：从前往后、从后往前等

5. 举例：举例推导dp数组

复杂一点的递推公式，dp[i]可能是需要自己处理来推出来的。而且，递推公式是通过观察得到的。。例如：
```java
// N0096 不同的二叉搜索树，递推公式
for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                // 递推公式
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
```

### 背包问题：

解题步骤（二维数组方式）：

- dp数组以及下标的含义：dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
- 递推公式：每次有两种情况，背包里放第i个物品，背包里不放第i个物品。两种取最大即可：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
- **初始化方式**：注意是倒叙，否则会多次重复放入物品。直接手动初始化也行，放得下就是物品0的价值，放不下就是0，如果有物品价值为负则是无穷小。**其他解法和题型，如一维数组等，要特别注意遍历顺序。**
   ```java
      // 倒叙遍历
      for (int j = bagWeight; j >= weight[0]; j--) {
          dp[0][j] = dp[0][j - weight[0]] + value[0]; // 初始化i为0时候的情况
      }
   ```
- **遍历顺序**：这里先容量后物品，或者先物品后容量都行。不过**其他解法和题型，如一维数组等，要特别注意遍历顺序**。
- 举例验证：略

解题步骤（一维数组方式）：可以看做是二维数组的简化版，相当于每次复制了上一层的值，复用了空间，所以少了一个维度。

- dp数组以及下标的含义：dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。其实是相当于把二维数组上一层的数据copy到本层，原本的“从0-i选取物品”被化解掉了，就只剩后半句“容量为j的背包，所背的最大物品价值”。
- 递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);。思路是一样的，j之前就两种情况，要么背了物品i，要么没背物品i，两者取最大即可。递推公式原本为dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);，copy后变为dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);，再化解就得到dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
- 初始化：容量为0，物品价值全部初始化为0即可。（如果物品价值有负，则取负无穷）
- **遍历顺序**：由于化解了一个物品增长的纬度。
  - 此时背包容量一定要从大到小遍历，否则会重复放入物品。
  - 此时一定是背包在外层循环，容量在里层循环。否则相当于是每次只放入一个物品。
- 举例验证：略。