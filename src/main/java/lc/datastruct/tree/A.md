二叉树

**满二叉树**
- 标准定义：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
- 大白话：最底层的叶子节点都是填满的。完完整整的三角形。

**完全二叉树**
- 标准定义：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
- 大白话：除了最底层节点没被填满，其他地方全部被填满。且最底层是从左到右填。
- 举例：优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。

**二叉搜索树**(二叉搜索树是一个有序树)：
- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

**平衡二叉搜索树**，即**AVL（Adelson-Velsky and Landis）树**：
- 是一棵空树
- 或者不为空时：左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

**二叉树的存储方式：**
- 数组：如果父节点的数组下标是i，那么它的左孩子就是i * 2 + 1，右孩子就是 i * 2 + 2。
- 链表：一般用这种方式存储。

**二叉树的遍历方式**
- 深度优先遍历：使用栈遍历。先往深走，遇到叶子节点再往回走。前中后遍历的区别，就是中在哪里。
  - 前序遍历（递归法，迭代法）：中左右。144题，优点是访问节点和处理节点一致，可以立即处理节点。
  - 中序遍历（递归法，迭代法）：左中右。94题，优点是天然有序，在作为二叉搜索树时。
  - 后序遍历（递归法，迭代法）：左右中。145题，优点是可以先查看子节点信息。
- 广度优先遍历：使用队列遍历。一层一层的去遍历。
  - 层次遍历（迭代法）

 **遍历方式实现方式** 
- 深度优先遍历的实现：用递归比较好实现，或者*用栈实现*。栈其实就是递归的一种是实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。

- 广度优先遍历的实现：一般*用队列来实现*，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

二叉树的定义：定义和链表差不多，不过二叉树的节点里多了一个指针，有两个指针，指向左右孩子。
```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
	
	
    public TreeNode(int x){
		this.val = x;
		this.left = null;
		this.right = null;
    }
};
```

递归算法的三个要素。**「每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！」**

1. **「确定递归函数的参数和返回值：」**确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **「确定终止条件：」**写完了递归算法,  运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **「确定单层递归的逻辑：」**确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

迭代法实现递归：使用栈模拟。**访问元素和处理元素不一致**时，用指针标记访问元素。

迭代法遍历特点：
1. 前序遍历和后续遍历while循环都是判断st是否为null。中序遍历还要加上判断next是否为null。
2. 后续遍历的标记位cur，标记的是上一个循环处理的节点，即pre。因为要判断现在是出去还是回来。
3. 中序遍历的标记位cur，标记的是下一个将要处理的节点，即next。因为是先入栈再处理，需要判断是否需要继续把下一个节点入栈。
4. 标记法的思路：先全部入栈，再处理。
5. 注意到st没有元素时，st.peek()是会报错的。所以peek()前要先判断st.isEmpty()。

递归三步曲：1.入参返回值。2.什么时候结束。3.单层逻辑。
递归函数什么时候要有返回值：**如果需要遍历整颗树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！因为遇到符合条件的路径之后要及时返回。**

二叉搜索树：节点是有序的。使用迭代法时，不需要用栈模拟递归。二叉搜索树遍历时也不用回溯，因为节点的有序性已经可以决定我们走的方向了。

map集合处理：
- 是否可为null：Key：除了HashMap，其他所有Map都不允许Key为null(如treeMap)。value：线程安全的Map都不允许Value为null（Hashtable，ConcurrentHashMap不可为null）。
- 遍历value：map.values()
```java
    for (Integer value : map.values()) {
     // ...
    }
```
- 遍历key：map.keySet()
```java
    for (Integer value : map.keySet()) {
     // ...
    }
```
- 遍历entry：map.entrySet()
```java
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
     // ...
    }
```
- List转换为Array: list.toArray(new String[]);
```java
// 示例1
ArrayList<String> list=new ArrayList<String>();
String[] strings = new String[list.size()];
list.toArray(strings);
```
- 数组转成List: Arrays.asList(String[] s);
```java
// 示例1
String[] s = {"a","b","c"};
List list = java.util.Arrays.asList(s);
// 示例2
List<Integer> results = new ArrayList<>();
Integer[] temp = new Integer[results.size()];
results.toArray(temp);
```





